// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package codegen

import (
	"cmp"
	"fmt"
	"generator/internal/spec"
	"io"
	"slices"
	"strconv"
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"
	"github.com/elastic/go-licenser/licensing"
	"github.com/fatih/camelcase"
)

// override types within the spec with native Go types.
var overrides = map[string]string{
	"_builtins.boolean": "bool",
	"_builtins.double":  "float64",
	"_builtins.integer": "int32",
	"_builtins.long":    "int64",
	"_types.boolean":    "bool",
	"_types.double":     "float64",
	"_types.integer":    "int32",
	"_types.long":       "int64",

	// NOTE: This is an override and divergence from the upstream specification.
	// It pins the 'if' property of processors, which are defined using
	// _types.Script, to be a string type instead of a struct. This is a
	// workaround solving issue:
	// https://github.com/andrewkroh/go-ingest-node/issues/15.
	"_types.Script": "string",
}

// acronyms is a set of acronyms that should be capitalized in identifiers.
var acronyms = map[string]bool{
	"csv":  true,
	"iana": true,
	"icmp": true,
	"id":   true,
	"ip":   true,
	"json": true,
	"kv":   true,
	"uri":  true,
	"url":  true,
	"os":   true,
}

// identifierFixes contains some special cases to make the identifier
// follow Go conventions.
var identifierFixes = map[string]string{
	"urldecode": "url_decode",
}

const (
	license  = "ASL2"
	licensor = "Elasticsearch B.V."
)

var licenseHeader string

func init() {
	var sb strings.Builder
	for _, line := range licensing.Headers[license] {
		if strings.Contains(line, "%s") {
			fmt.Fprintf(&sb, line, licensor)
			sb.WriteByte('\n')
			continue
		}
		sb.WriteString(line)
		sb.WriteByte('\n')
	}

	licenseHeader = sb.String()
}

type Generator struct {
	allTypes map[spec.TypeName]*spec.TypeDefinition
}

func New(model *spec.Model) *Generator {
	b := &Generator{
		allTypes: map[spec.TypeName]*spec.TypeDefinition{},
	}
	for i, t := range model.Types {
		switch v := t.Value.(type) {
		case spec.Interface:
			b.allTypes[v.TypeName] = &model.Types[i]
		case spec.TypeAlias:
			b.allTypes[v.TypeName] = &model.Types[i]
		case spec.Enum:
			b.allTypes[v.TypeName] = &model.Types[i]
		}
	}
	return b
}

func (b *Generator) BuildCode(w io.Writer, typeSelector func(name, inherits spec.TypeName) bool) error {
	selected := map[spec.TypeName]*spec.TypeDefinition{}
	deps := map[spec.TypeName]bool{}

	for n, t := range b.allTypes {
		var name, inherits spec.TypeName
		switch v := t.Value.(type) {
		case spec.Interface:
			name = v.TypeName
			inherits = v.Inherits.TypeName
		case spec.TypeAlias:
			name = v.TypeName
		case spec.Enum:
			name = v.TypeName
		default:
			panic(fmt.Errorf("unhandled type kind %T", t.Value))
		}

		if typeSelector(name, inherits) {
			selected[n] = t
			b.depsOfType(t, deps)
		}
	}

	// Add dependencies to the list.
	for d := range deps {
		// Skip overwritten types.
		if _, found := overrides[qualifiedName(d.Namespace, d.Name)]; found {
			continue
		}

		if t := b.allTypes[d]; t != nil {
			selected[d] = t
		}
	}

	// Setup file.
	f := jen.NewFile("ingestnode")
	f.HeaderComment(licenseHeader)
	f.Line()
	f.PackageComment("Code generated by github.com/andrewkroh/go-ingest-node/internal/generator, DO NOT EDIT.")

	// Organize code by types.
	var enums []*spec.Enum
	var aliases []*spec.TypeAlias
	var ifcs []*spec.Interface

	for _, t := range selected {
		switch v := t.Value.(type) {
		case spec.Enum:
			enums = append(enums, &v)
		case spec.TypeAlias:
			aliases = append(aliases, &v)
		case spec.Interface:
			ifcs = append(ifcs, &v)
		}
	}
	slices.SortFunc(enums, func(a, b *spec.Enum) int {
		return cmp.Compare(a.TypeName.Name, b.TypeName.Name)
	})
	slices.SortFunc(aliases, func(a, b *spec.TypeAlias) int {
		return cmp.Compare(a.TypeName.Name, b.TypeName.Name)
	})
	slices.SortFunc(ifcs, func(a, b *spec.Interface) int {
		return cmp.Compare(a.TypeName.Name, b.TypeName.Name)
	})

	f.Comment("Enum types.").Line()
	for _, e := range enums {
		if err := b.addEnum(f, e); err != nil {
			return err
		}
	}

	f.Comment("Type aliases.").Line()
	f.Type().DefsFunc(func(g *jen.Group) {
		for _, a := range aliases {
			b.addTypeAlias(g, a)
		}
	})

	f.Comment("Structs.").Line()
	for _, i := range ifcs {
		if err := b.addInterface(f, i); err != nil {
			return err
		}
	}
	return f.Render(w)
}

func (b *Generator) addEnum(f *jen.File, e *spec.Enum) error {
	f.Type().Id(e.TypeName.Name).Id("string")
	f.Line()

	f.Const().DefsFunc(func(g *jen.Group) {
		for _, m := range e.Members {
			g.Id(goIDName(strings.ToLower(m.Name) + "_" + e.TypeName.Name)).Id(e.TypeName.Name).Op("=").Lit(m.Name)
		}
	})
	f.Line()
	return nil
}

func (b *Generator) addTypeAlias(g *jen.Group, a *spec.TypeAlias) {
	g.Id(a.TypeName.Name).Id(identifier(a.Type))
}

func (b *Generator) addInterface(f *jen.File, ifc *spec.Interface) error {
	err := b.goStruct(ifc, f)
	if err != nil {
		return err
	}

	f.Line()
	return nil
}

func (b *Generator) addInheritedFields(g *jen.Group, ifc *spec.Interface) error {
	if ifc.Inherits.TypeName.Name == "" {
		return nil
	}

	parent, found := b.allTypes[ifc.Inherits.TypeName]
	if !found {
		return fmt.Errorf("failed to find parent type %s.%s", ifc.Inherits.TypeName.Namespace, ifc.Inherits.TypeName.Name)
	}

	ifcType, ok := parent.Value.(spec.Interface)
	if !ok {
		return fmt.Errorf("%s inherits from an unexpected kind %T", ifc.TypeName.Name, parent)
	}

	b.addProperties(g, ifcType.Properties)
	return nil
}

func (b *Generator) addProperties(g *jen.Group, props []spec.Property) {
	for _, p := range props {
		required := p.Required != nil && *p.Required

		s := g.Id(goIDName(p.Name))
		switch {
		case p.Type.InstanceOf != nil:
			if !required {
				s.Op("*")
			}
			s.Id(identifier(p.Type))
		case p.Type.ArrayOf != nil:
			v := p.Type.ArrayOf.Value

			if v.UserDefinedValue != nil {
				// NOTE: AppendProcessor uses array_of user_defined_value, but the processor really accepts both a scalar and a list.
				// https://github.com/elastic/elasticsearch-specification/issues/2308
				s.Id("any")
			} else {
				s.Index().Id(identifier(p.Type.ArrayOf.Value))
			}
		case p.Type.DictionaryOf != nil:
			s.Map(jen.String()).Id(identifier(p.Type.DictionaryOf.Value))
		case p.Type.UnionOf != nil:
			s.Id("any")
		case p.Type.UserDefinedValue != nil:
			s.Id("any")
		}

		s.Tag(b.structTag(&p))
		if p.Description != nil {
			s.Comment(comment(&p))
		}
	}
}

func (b *Generator) goStruct(ifc *spec.Interface, f *jen.File) error {
	var err error
	f.Type().Id(ifc.TypeName.Name).StructFunc(func(g *jen.Group) {
		if err = b.addInheritedFields(g, ifc); err != nil {
			return
		}
		b.addProperties(g, ifc.Properties)
	})

	return err
}

func (b *Generator) depsOfType(t *spec.TypeDefinition, deps map[spec.TypeName]bool) {
	if t == nil {
		return
	}

	switch v := t.Value.(type) {
	case spec.Interface:
		for _, p := range v.Properties {
			b.depsOfValue(p.Type, deps)
		}
	case spec.TypeAlias:
		b.depsOfValue(v.Type, deps)
	}
}

func (b *Generator) depsOfValue(v *spec.ValueOf, deps map[spec.TypeName]bool) {
	switch {
	case v.InstanceOf != nil:
		if _, visited := deps[v.InstanceOf.TypeName]; !visited {
			deps[v.InstanceOf.TypeName] = true
			b.depsOfType(b.allTypes[v.InstanceOf.TypeName], deps)
		}
	case v.ArrayOf != nil:
		b.depsOfValue(v.ArrayOf.Value, deps)
	case v.DictionaryOf != nil:
		b.depsOfValue(v.DictionaryOf.Key, deps)
		b.depsOfValue(v.DictionaryOf.Value, deps)
	case v.UnionOf != nil:
		for _, item := range v.UnionOf.Items {
			b.depsOfValue(item, deps)
		}
	}
}

func identifier(v *spec.ValueOf) string {
	switch {
	case v.InstanceOf != nil:
		if o := overrides[qualifiedName(v.InstanceOf.Namespace, v.InstanceOf.TypeName.Name)]; o != "" {
			return o
		}
		return v.InstanceOf.TypeName.Name
	case v.ArrayOf != nil:
		return identifier(v.ArrayOf.Value)
	case v.UnionOf != nil:
		// TODO: Handle multiple types by creating an intermediary type that can handle
		// the marshaling/unmarshalling the individual types contained in the union.
		return "any"
	case v.UserDefinedValue != nil:
		return "any"
	case v.LiteralValue != nil:
		return fmt.Sprintf("%s", v.LiteralValue.Value)
	case v.DictionaryOf != nil:
		return fmt.Sprintf("map[%s]%s", identifier(v.DictionaryOf.Key), identifier(v.DictionaryOf.Value))
	}
	return ""
}

// goIDName returns a Go identifier representing the configuration option name.
func goIDName(name string) string {
	if fix, found := identifierFixes[strings.ToLower(name)]; found {
		name = fix
	}

	snakeCaseParts := strings.FieldsFunc(name, func(r rune) bool {
		return unicode.IsPunct(r)
	})

	var allParts []string
	for _, p := range snakeCaseParts {
		allParts = append(allParts, camelcase.Split(p)...)
	}

	for i, p := range allParts {
		if _, isAcronym := acronyms[strings.ToLower(p)]; isAcronym {
			allParts[i] = strings.ToTitle(p)
			continue
		}

		allParts[i] = strings.Title(p)
	}

	return strings.Join(allParts, "")
}

// structTag returns a struct tag for json, yaml, and jsonschema.
func (b *Generator) structTag(p *spec.Property) map[string]string {
	tag := jsonTag(p)
	tags := map[string]string{
		"json": tag,
		"yaml": tag,
	}

	if tag = b.jsonschemaTag(p); tag != "" {
		tags["jsonschema"] = tag
	}
	return tags
}

// jsonschemaTag generates the jsonschema struct tag value used by
// github.com/invopop/jsonschema.
func (b *Generator) jsonschemaTag(p *spec.Property) string {
	var tagParts []string

	// Enum values.
	if p.Type.InstanceOf != nil {
		if typeInfo, found := b.allTypes[p.Type.TypeName]; found {
			if enum, ok := typeInfo.Value.(spec.Enum); ok {
				for _, member := range enum.Members {
					tagParts = append(tagParts, "enum="+member.Name)
				}
			}
		}
	}

	// Default value.
	switch v := p.ServerDefault.(type) {
	case nil:
	case string:
		// Data cleaning.
		v = trimBalanced(v, '`')
		v = trimBalanced(v, '"')
		v = trimBalanced(v, '\'')

		if v != "" && v != "null" {
			tagParts = append(tagParts, "default="+escapeTagPart(v))
		}
	case []any:
		for _, v := range v {
			switch v := v.(type) {
			case string:
				tagParts = append(tagParts, "default="+escapeTagPart(v))
			default:
				panic(fmt.Errorf("unhandled type %T for default found in array for %s", v, p.Name))
			}
		}
	case bool:
		tagParts = append(tagParts, "default="+strconv.FormatBool(v))
	case float64:
		tagParts = append(tagParts, "default="+strconv.FormatFloat(v, 'g', -1, 64))
	default:
		panic(fmt.Errorf("unhandled type %T for default found for %s", v, p.Name))
	}

	return strings.Join(tagParts, ",")
}

// jsonTag generates the json struct tag value for a property.
func jsonTag(p *spec.Property) string {
	tag := p.Name
	required := p.Required != nil && *p.Required

	if !required {
		tag += ",omitempty"
	}
	return tag
}

// comment returns the field description with punctuation and information about
// whether it is required.
func comment(p *spec.Property) string {
	var sb strings.Builder
	if p.Description != nil {
		d := strings.ReplaceAll(*p.Description, "\n", " ")
		d = strings.TrimSpace(d)
		sb.WriteString(d)
	}
	if sb.Len() > 0 && !strings.HasSuffix(sb.String(), ".") {
		sb.WriteByte('.')
	}
	if p.Required != nil && *p.Required {
		if sb.Len() > 0 {
			sb.WriteByte(' ')
		}
		sb.WriteString("Required.")
	}
	return sb.String()
}

// trimBalanced removes the leading and trailing character if they are balanced.
func trimBalanced(s string, c rune) string {
	if len(s) >= 2 && rune(s[0]) == c && rune(s[len(s)-1]) == c {
		return s[1 : len(s)-1]
	}
	return s
}

// escapeTagPart escapes commas in struct tag values.
func escapeTagPart(s string) string {
	return strings.ReplaceAll(s, ",", `\,`)
}

// qualifiedName returns the combined type namespace and type name.
func qualifiedName(ns, name string) string {
	return ns + "." + name
}
